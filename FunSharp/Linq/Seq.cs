using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;

namespace FunSharp.Linq
{
    /// <summary>Utility class for creating sequences.</summary>
    public static class Seq
    {
        /// <summary>Creates a sequence by repeatedly applying an accumulator function from a seed value.</summary>
        /// <typeparam name="T">The element type of the output sequence.</typeparam>
        /// <typeparam name="TAcc">The type of the accumulator value.</typeparam>
        /// <param name="f">Accumulator function to optionally create a new value and accumulator value from the current accumulator value.</param>
        /// <param name="init">The initial accumulator value.</param>
        /// <returns>The sequence of value generated by the repeated application of the accumulator function to <paramref name="init"/>.</returns>
        public static IEnumerable<T> Unfold<T, TAcc>(Func<TAcc, Maybe<Tuple<T, TAcc>>> f, TAcc init)
        {
            Contract.Requires(f != null);

            TAcc acc = init;
            Maybe<Tuple<T, TAcc>> mPair;
            while ((mPair = f(acc)).HasValue)
            {
                yield return mPair.Value.Item1;
                acc = mPair.Value.Item2;
            }
        }

        /// <summary>Creates a non-empty sequence of values.</summary>
        /// <typeparam name="T">The element type of the sequence.</typeparam>
        /// <param name="first">The first element in the sequence.</param>
        /// <param name="rest">The remaining elements of the sequence.</param>
        /// <returns>A non-empty sequence containing <paramref name="first"/> followed by the elements of <paramref name="rest"/>.</returns>
        public static INonEmptyEnumerable<T> NonEmpty<T>(T first, IEnumerable<T> rest)
        {
            Contract.Requires(rest != null);
            return new NonEmptyEnumerable<T>(first, rest);
        }

        /// <summary>Creates a sequence containing a single element.</summary>
        /// <typeparam name="T">The element type of the sequence.</typeparam>
        /// <param name="item">The single element of the sequence.</param>
        /// <returns>A sequence containing <paramref name="item"/>.</returns>
        public static INonEmptyEnumerable<T> Singleton<T>(T item)
        {
            return new NonEmptyEnumerable<T>(item, System.Linq.Enumerable.Empty<T>());
        }
    }
}
